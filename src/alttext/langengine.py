from abc import ABC, abstractmethod
import requests


### LANGENGINE CLASSES
class LangEngine(ABC):
    @abstractmethod
    def _completion(self, prompt: str) -> str:
        """Sends message to language model and returns its response.

        Args:
            prompt (str): Prompt to send to language model.

        Returns:
            str: Response from language model.
        """
        pass

    @abstractmethod
    def refineDesc(self, description: str) -> str:
        """Refines description of an image.
        Used in V1 Dataflow.

        Args:
            description (str): Description of an image.

        Returns:
            str: Refinement of description.
        """
        pass

    @abstractmethod
    def refineOCR(self, chars: str) -> str:
        """Refines characters found in an image.
        Used in V1 Dataflow.

        Args:
            chars (str): Characters found in an image.

        Returns:
            str: Refinement of characters.
        """
        pass

    @abstractmethod
    def genPrompt(self, desc: str, chars: str, context: list[str], caption: str) -> str:
        """Generates prompt to send to language model in V2 Dataflow.

        Args:
            desc (str): Description of an image.
            chars (str): Characters found in an image.
            context (list[str]): Context of an image. See getContext in alttext for more information.
            caption (str): Caption of an image.

        Returns:
            str: Prompt to send to language model.
        """
        pass

    @abstractmethod
    def refineAlt(
        self,
        desc: str,
        chars: str = None,
        context: list[str] = None,
        caption: str = None,
    ) -> str:
        """Generates alt-text for an image.
        Used in V2 Dataflow.

        Args:
            desc (str): Description of an image.
            chars (str, optional): Characters found in an image. Defaults to None.
            context (list[str], optional): Context of an image. See getContext in alttext for more information. Defaults to None.
            caption (str, optional): Caption of an image. Defaults to None.

        Returns:
            str: Alt-text for an image.
        """
        pass

    @abstractmethod
    def ingest(self, filename: str, binary) -> bool:
        """Ingests a file into the language model.

        Args:
            filename (str): Name of file.
            binary (_type_): Data of file.

        Returns:
            bool: True if successful.
        """
        pass

    @abstractmethod
    def degest(self, filename: str) -> bool:
        """Removes a file from the language model.

        Args:
            filename (str): Name of file.

        Returns:
            bool: True if successful.
        """
        pass


### IMPLEMENTATIONS
class PrivateGPT(LangEngine):
    def __init__(self, host) -> None:
        self.host = host

    def __setHost(self, host) -> bool:
        self.host = host
        return True

    def _completion(self, prompt: str) -> str:
        body = {
            "include_sources": False,
            "prompt": prompt,
            "stream": False,
            "use_context": True,
        }
        r = requests.post(f"{self.host}/v1/completions", json=body)
        r = r.json()
        return r["choices"][0]["message"]["content"].strip()

    def refineDesc(self, description: str) -> str:
        prompt = f"""The following string surrounded with '///' was generated by an Image Captioning AI when ran on some arbitrary image.
///{description}///

Your goal is to refine the string to be inserted as alt-text for an image in an Ebook.

Here are guidelines to follow...
1. Prioritize information in text alternative:
Aim to put the most important information at the beginning.
2. Length of the text alternative:
The alt text should be the most concise description possible of the image's purpose. If anything more than a short phrase or sentence is needed, it would be better to use one of the long description methods discussed in complex images.
3. Superfluous information in the text alternative:
Usually, there's no need to include words like “image”, “icon”, or “picture” in the alt text. People who can see will know this already, and screen readers announce the presence of an image. In some situations, it may be important to distinguish between paintings, photographs, or illustrations, etc., but it's best to avoid the more generic use of the terms.

Format your response as...
The refined string is: <refined_string>

If the string is empty, simply respond with...
The refined string is: N/A"""
        return self._completion(prompt)

    def refineOCR(self, chars: str) -> str:
        prompt = f"""The following string surrounded with '///' was generated by an Optical Character Recognition software when ran on some arbitrary image.
///
{chars}
///

Your goal is to refine the string.
There may be random/excess spaces or other characters in the string, please remove them.
Do not surround the refined string in quotation marks.

Format your response as...
The refined string is: <refined_string>

If the string is empty, simply respond with...
The refined string is: N/A"""
        return self._completion(prompt)

    def genPrompt(self, desc: str, chars: str, context: list[str], caption: str) -> str:
        ocr = ""
        if chars != None and chars != "":
            ocr = f"\nThe following string surrounded with '///' was generated by an Optical Character Recognition software when ran on the image.\n///{chars}///"
        before = ""
        if context[0] != None and context[0] != "":
            before = f"\nThe following string surrounded with '///' is the nearest text found before the image.\n///{context[0]}///"
        after = ""
        if context[1] != None and context[1] != "":
            after = f"\nThe following string surrounded with '///' is the nearest text found after the image.\n///{context[1]}///"
        cap = ""
        if caption != None and caption != "":
            cap = f"\nThe following string surrounded with '///' is a caption in the Ebook for the image.\n///{caption}///"

        prompt = f"""There following information is regarding an image found in an Ebook with no alternative-text.
The following string surrounded with '///' was generated by an Image Captioning AI when ran on the image.
///{desc}///{ocr}{cap}{before}{after}

Your goal is to create alternative-text for the image given the prior information.

Here are guidelines to follow to create quality alt-text...
1. Prioritize information in text alternative:
Aim to put the most important information at the beginning.
2. Length of the text alternative:
The alt text should be the most concise description possible of the image's purpose. If anything more than a short phrase or sentence is needed, it would be better to use one of the long description methods discussed in complex images.
3. Superfluous information in the text alternative:
Usually, there's no need to include words like “image”, “icon”, or “picture” in the alt text. People who can see will know this already, and screen readers announce the presence of an image. In some situations, it may be important to distinguish between paintings, photographs, or illustrations, etc., but it's best to avoid the more generic use of the terms.

Using all of the information stated, please generate alt-text for the image.
In your response, please only give the alt-text."""
        return prompt

    def refineAlt(
        self,
        desc: str,
        chars: str = None,
        context: list[str] = None,
        caption: str = None,
    ) -> str:
        prompt = self.genPrompt(
            desc,
            chars,
            context,
            caption,
        )
        return self._completion(prompt)

    def ingest(self, filename: str, binary) -> bool:
        ext = filename.split(".")[1]
        files = {"file": (filename, binary, f"application/{ext}")}
        headers = {"accept": "application/json"}
        r = requests.post(f"{self.host}/v1/ingest", files=files, headers=headers)
        return True

    def degest(self, filename: str) -> bool:
        headers = {"accept": "application/json"}
        r = requests.delete(f"{self.host}/v1/ingest/{filename}", headers=headers)
        return True
